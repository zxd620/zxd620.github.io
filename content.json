{"meta":{"title":"赵晓东的网络日志","subtitle":"一个立志AI的嵌入式+硬件+后端+信号处理工程师","description":null,"author":"赵晓东","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"阿里云Centos7.5安装MongoDB","slug":"阿里云Centos7.5安装MongoDB","date":"2019-08-20T07:58:40.756Z","updated":"2019-08-20T12:02:19.613Z","comments":true,"path":"2019/08/20/阿里云Centos7.5安装MongoDB/","link":"","permalink":"http://yoursite.com/2019/08/20/阿里云Centos7.5安装MongoDB/","excerpt":"","text":"运行环境：阿里云Centos7.5参考：官方手册安装选择使用.rpm包安装的方式 1.配置包管理系统（yum） 创建一个/etc/yum.repos.d/mongodb-org-4.0.repo文件，这样就可以直接通过yum来安装MongoDB了 [mongodb-org-4.0]name=MongoDB Repositorybaseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/4.2/x86_64/gpgcheck=1enabled=1gpgkey=https://www.mongodb.org/static/pgp/server-4.2.asc 注意： 奇数版本是开发版本，不适用于生产环境使用。 2.安装MongoDB包 使用如下命令安装稳定版本： 1sudo yum install -y mongodb-org 想安装MongoDB的特定release版本的话，单独指定每个内容包，在包名上追加上版本号，比如下面的例子： 1sudo yum install -y mongodb-org-4.2.0 mongodb-org-server-4.2.0 mongodb-org-shell-4.2.0 mongodb-org-mongos-4.2.0 mongodb-org-tools-4.2.0 3.配置/etc/yum.conf，指定不自动更新mongodb相关程序。虽然可以指定版本，但是，当有更新版本的时候，yum会自动更新。为避免非预期的更新，保持版本，在/etc/yum.conf文件中增加如下排除指令： exclude=mongodb-org,mongodb-org-server,mongodb-org-shell,mongodb-org-mongos,mongodb-org-tools 运行前准备推荐使用默认路径，默认路径为： /var/lib/mongo（data路径） /var/log/mongodb（log路径） 若使用自定义路径，则： 1.首先创建相关路径， 2.在配置文件/etc/mongod.conf中进行如下修改： storage.dbPath指定为新的data路径(e.g. /some/data/directory) systemLog.path指定为新的log文件路径（不同于data，不是文件夹路径,e.g. /some/log/directory/mongod.log） 3.确保运行MongoDB的用户，拥有所设置路径的访问权限 1chown -R mongod:mongod &lt;directory&gt; 如果更改了用户，则必须给改用户赋予访问路径的权限 4.必须配置SELinux 运行1.开启MongoDB服务 1sudo service mongod start 或者 1systemctl start mongod.service 2.验证开启成功查看log文件内容，是否新增了如下行： 1[initandlisten] waiting for connections on port &lt;port&gt; 其中是/etc/mongod.conf中配置的，默认为270173.（可选）设置MongoDB开机自启动 1sudo chkconfig mongod on 4.停止MongoDB 1sudo service mongod stop 或者 1systemctl stop mongod.service 5.重启MongoDB 1sudo service mongod restart 或者 1systemctl restart mongod.service 运行结果： [root@VM_0_16_centos PFD]# sudo chkconfig mongod onNote: Forwarding request to ‘systemctl enable mongod.service’. 这并不表示运行错误，只是额外提醒，需要确认服务开启了。6.使用MongoDB本地使用mongo shell，则直接运行： 1mongo 在不同主机或者不同port运行，则参考The mongo Shell","categories":[],"tags":[]},{"title":"Socket与Port的关系","slug":"socket与port的关系","date":"2019-08-20T05:50:48.785Z","updated":"2019-08-20T14:31:58.677Z","comments":true,"path":"2019/08/20/socket与port的关系/","link":"","permalink":"http://yoursite.com/2019/08/20/socket与port的关系/","excerpt":"","text":"何为socket 服务器进程首先要绑定一个端口并监听来自其他客户端的连接。如果某个客户端连接过来了，服务器就与该客户端建立Socket连接，随后的通信就靠这个Socket连接了。 所以，服务器会打开固定端口（比如80）监听，每来一个客户端连接，就创建该Socket连接。由于服务器会有大量来自客户端的连接，所以，服务器要能够区分一个Socket连接是和哪个客户端绑定的。一个Socket依赖4项：服务器地址、服务器端口、客户端地址、客户端端口来唯一确定一个Socket。 但是服务器还需要同时响应多个客户端的请求，所以，每个连接都需要一个新的进程或者新的线程来处理，否则，服务器一次就只能服务一个客户端了。（注：nodejs则通过异步+回调来实现） 同一个端口，被一个Socket绑定了以后，就不能被别的Socket绑定了。 关于客户端Socket与Port的关系在使用nodejs模拟客户端进行高并发测试时，单个进程每隔100ms创建一个Socket，创建len个，那么这些Socket是对应了不同Port吗？ 运行环境 Centos7.5node v10.16.0 appDevice.js 12345678910111213141516171819202122232425262728293031323334353637let args = process.argv.splice(2);let devId_base = args[0];devId_base =1;// console.log(&apos;Device:devId_base= &apos; + devId_base);const len = 5;let i = 1;let socket_set = function () &#123; let devId = len * (parseInt(devId_base) - 1) + i + &apos;&apos;; console.log(&apos;Device=&apos; + devId + &apos;:\\tstart&apos;); let socket = require(&apos;socket.io-client&apos;)(&apos;http://xxx.xx.xx.xxx:80&apos;); let monitor = false; socket.emit(&apos;ASK_JOIN_D&apos;, &#123; devId: devId &#125;); let worker = function () &#123; if (monitor) &#123; let timeStamp = new Date().getTime(); // console.log(&apos;Device=&apos; + devId + &apos;:\\temit\\tdata_RT &apos; + timeStamp); socket.emit(&apos;data_RT&apos;, [timeStamp, 11, 22, 44]); &#125; //socket.send(&#123;msg: &apos;send data&apos;&#125;); &#125;; setInterval(worker, 3000); // setTimeout(function () &#123; console.log(&apos;stop run&apos;);&#125;, 100000); i++; if (i == len + 1) &#123; i = 1; clearInterval(timer); &#125;&#125;let timer = setInterval(socket_set, 100); 运行： 1node appDevice.js 1 创建了5个Socket，依次执行如下步骤： 确定该进程pid 1ps -ef |grep &apos;node ./app&apos;|grep -v grep 结果： 1root 7915 1 1 21:53 pts/0 00:00:00 node ./appDevice.js 1 查询对应pid占用的port 1netstat -nap | grep 7915 结果： 可以看到，进程占用了5个Port，一个Socket对应了一个Port。 结论：对于客户端，创建socket的时候，会随机分配一个Port到该Socket，每个Socket都对应一个Port。 关于服务器Socket与Port的关系参考此文的问答：TCP server 为什么一个端口可以建立多个连接？ 对于TCP协议，要成功建立一个新的链接，需要保证新链接四个要素组合体的唯一性：客户端的IP、客户端的port、服务器端的IP、服务器端的port。也就是说，服务器端的同一个IP和port，可以和同一个客户端的多个不同端口成功建立多个TCP链接（与多个不同的客户端当然也可以），只要保证【Server IP + Server Port + Client IP + Client Port】这个组合唯一不重复即可。 客户端发送TCP链接请求的端口，也就是后续建立TCP链接使用的端口，所以一旦TCP链接建立，端口就被占用，无法再建立第二个链接。 而服务器端有两类端口：侦听端口 和 后续建立TCP链接的端口。其中侦听端口只负责侦听客户端发送来的TCP链接请求，不用作建立TCP链接使用，一旦侦听到有客户端发送TCP链接请求，就分配一个端口（一般随机分配，且不会重复）用于建立TCP链接，而不是所说的服务器一个端口能建立多个连接。 以下为测试结果:7476为此服务器上node的进程pid，在收到来自同一个客户端的5个请求后，分配了5个Port给5个Socket 结论：一旦侦听到有客户端发送TCP链接请求，就分配一个端口（一般随机分配，且不会重复）用于建立TCP链接","categories":[],"tags":[]},{"title":"Secucrt，vim插件以及系统语言LANG 对printf的影响","slug":"Secucrt，vim插件以及系统语言LANG-对printf的影响","date":"2019-08-15T02:07:43.000Z","updated":"2019-08-20T05:49:20.091Z","comments":true,"path":"2019/08/15/Secucrt，vim插件以及系统语言LANG-对printf的影响/","link":"","permalink":"http://yoursite.com/2019/08/15/Secucrt，vim插件以及系统语言LANG-对printf的影响/","excerpt":"","text":"问题：安装vim插件vim设置： encoding=utf-8，内部机制，不要改变，在任何时候都不要试图修改encoding设置 termencoding=utf-8，vim输出到终端显示用，只涉及到显示，不涉及文件内容的改变 fileencodings=utf-8,ucs-bom,gbk,cp936,gb2312,gb18030，依次识别文件用 两个现象： 若服务器端系统LANG、secucrt按照GBK来设置，那么vim打开GB2313编码的文档无法正常显示，但gcc编译运行时，printf打印中文正常显示在终端secucrt； 解决方法：更改vim插件设置，~/.vimrc中termencoding=GBK 此时，gcc编译选择文件编码类型为GB2312或GBK的话，程序printf中文输出会乱码，应不指定（默认为utf-8），或者指定为utf-8则输出正确。这个现象，暂时无法解释。 若服务器端系统LANG、secucrt按照utf8来设置，那么vim打开GB2312编码的文档时可以正常显示中文（跟vim插件也有关，termencoding=utf-8），但是gcc后的程序，printf的中文结果乱码解决方案：gcc 编译时，加上对文档字符集的指定 -finput-charset=GB2312才能正常printf中文 解决方法：将main.c使用vscode转换为utf8，无论是否带bom，则不再需要指定-finput-charset就可正常printf中文；无论如何，掌握原则如下： 服务端系统语言设置为UTF-8，secucrt设置为utf-8，参考《远程SSH连接Linux中文乱码》的方案二； 代码以UTF-8格式创建和编写以及保存和gcc编译运行； 若代码文档格式为GBK或者GB2312等，则编译运行时应制定gcc的选项-finput-charset； 参考：vim插件[gcc编译选项http://blog.chinaunix.net/uid-28458801-id-4515769.htmlvim encoding fileencoding termencoding 疑问1：-finput-charset 指定源文件的编码（若不指定，默认是UTF-8）-fexec-charset 指定多字节字符串(const char)常量在编译后的程序里保存的编码集（若不指定，默认是UTF-8）-fwide-exec-charset 指定宽字节字符串(const wchar_t)常量在编译后的程序里的保存的编码集 这几个编译选项的区别含义不是很明白； 疑问2：","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-08-14T12:32:56.377Z","updated":"2019-08-14T12:32:56.378Z","comments":true,"path":"2019/08/14/hello-world/","link":"","permalink":"http://yoursite.com/2019/08/14/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}